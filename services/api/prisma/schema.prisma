// Vlossom Protocol - Database Schema
// Reference: docs/vlossom/06-database-schema.md
// Reference: docs/specs/booking-flow-v1/feature-spec.md

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// ENUMS
// ============================================================================

enum ActorRole {
  CUSTOMER
  STYLIST
  PROPERTY_OWNER
  ADMIN
}

enum VerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  SUSPENDED
}

enum OperatingMode {
  MOBILE
  FIXED
  HYBRID
}

enum LocationType {
  STYLIST_BASE
  CUSTOMER_HOME
}

enum BookingStatus {
  PENDING_STYLIST_APPROVAL
  PENDING_CUSTOMER_PAYMENT
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  AWAITING_CUSTOMER_CONFIRMATION
  SETTLED
  CANCELLED
  DECLINED
  DISPUTED
}

enum EscrowStatus {
  LOCKED
  RELEASED
  REFUNDED
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  TRANSFER_IN
  TRANSFER_OUT
  ESCROW_LOCK
  ESCROW_RELEASE
  ESCROW_REFUND
  FAUCET_CLAIM
}

enum TransactionStatus {
  PENDING
  CONFIRMED
  FAILED
}

enum PaymentRequestStatus {
  PENDING
  COMPLETED
  EXPIRED
  CANCELLED
}

enum DisputeStatus {
  OPEN
  ASSIGNED
  UNDER_REVIEW
  RESOLVED
  ESCALATED
  CLOSED
}

enum DisputeType {
  SERVICE_NOT_DELIVERED
  POOR_QUALITY
  LATE_ARRIVAL
  NO_SHOW
  PROPERTY_DAMAGE
  PAYMENT_ISSUE
  COMMUNICATION_ISSUE
  SAFETY_CONCERN
  OTHER
}

enum DisputeResolution {
  FULL_REFUND_CUSTOMER
  PARTIAL_REFUND
  NO_REFUND
  SPLIT_FUNDS
  STYLIST_PENALTY
  CUSTOMER_WARNING
  MUTUAL_CANCELLATION
  ESCALATED_TO_LEGAL
}

// ============================================================================
// MODELS
// ============================================================================

/// Core user entity - supports role fluidity
model User {
  id                 String             @id @default(uuid())
  walletAddress      String             @unique
  email              String?            @unique
  phone              String?            @unique
  passwordHash       String?            // bcrypt hash (only for email/password users)
  displayName        String
  avatarUrl          String?
  roles              Json               @default("[]") // ActorRole[]
  verificationStatus VerificationStatus @default(UNVERIFIED)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  // Relations
  stylistProfile      StylistProfile?
  bookingsAsCustomer  Booking[]                @relation("CustomerBookings")
  bookingsAsStylist   Booking[]                @relation("StylistBookings")
  statusChanges       BookingStatusHistory[]
  wallet              Wallet?
  savedPaymentMethods SavedPaymentMethod[]

  // V3.2: Multi-auth relations
  externalProviders   ExternalAuthProvider[]
  linkedAccounts      LinkedAccount[]

  // Password reset tokens
  passwordResetTokens PasswordResetToken[]

  @@index([walletAddress])
  @@index([email])
  @@index([phone])
  @@map("users")
}

/// Password reset token for email-based recovery
model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
  @@map("password_reset_tokens")
}

/// Stylist profile data
model StylistProfile {
  id                  String        @id @default(uuid())
  userId              String        @unique
  bio                 String?
  specialties         Json          @default("[]") // string[]
  serviceCategories   Json          @default("[]") // string[]
  portfolioImages     Json          @default("[]") // string[]
  operatingMode       OperatingMode
  serviceRadius       Int?          // km for mobile stylists
  baseLocationLat     Float?
  baseLocationLng     Float?
  baseLocationAddress String?
  isAcceptingBookings Boolean       @default(true)
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  // Relations
  user         User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  services     StylistService[]
  availability StylistAvailability?

  @@index([userId])
  @@index([isAcceptingBookings])
  @@map("stylist_profiles")
}

/// Stylist weekly availability schedule and exceptions
model StylistAvailability {
  id        String   @id @default(uuid())
  stylistId String   @unique
  schedule  Json     @default("{}") // Weekly schedule: {mon: [{start: "09:00", end: "17:00"}], ...}
  exceptions Json    @default("[]") // Date exceptions: [{date: "2025-12-25", blocked: true, note: "Christmas"}]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  stylist StylistProfile @relation(fields: [stylistId], references: [id], onDelete: Cascade)

  @@index([stylistId])
  @@map("stylist_availability")
}

/// Individual service offering by stylist
model StylistService {
  id                   String   @id @default(uuid())
  stylistId            String
  name                 String
  category             String
  description          String?
  priceAmountCents     BigInt   // Use BigInt to avoid floating point issues
  estimatedDurationMin Int
  isActive             Boolean  @default(true)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  // Relations
  stylist  StylistProfile @relation(fields: [stylistId], references: [id], onDelete: Cascade)
  bookings Booking[]

  @@index([stylistId])
  @@index([category])
  @@index([isActive])
  @@map("stylist_services")
}

/// Core booking entity
model Booking {
  id         String   @id @default(uuid())
  customerId String
  stylistId  String
  serviceId  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Service details
  serviceType          String
  serviceCategory      String
  estimatedDurationMin Int
  actualDurationMin    Int?

  // Scheduling
  scheduledStartTime DateTime
  scheduledEndTime   DateTime
  actualStartTime    DateTime?
  actualEndTime      DateTime?

  // Location
  locationType    LocationType
  locationAddress String
  locationLat     Float?
  locationLng     Float?

  // Pricing (all in cents, stored as BigInt)
  quoteAmountCents    BigInt
  finalAmountCents    BigInt?
  platformFeeCents    BigInt
  stylistPayoutCents  BigInt
  propertyPayoutCents BigInt? @default(0)

  // Status
  status BookingStatus

  // Escrow
  escrowId     String?
  escrowStatus EscrowStatus?

  // Cancellation
  cancelledAt     DateTime?
  cancelledBy     String? // userId or "SYSTEM"
  cancellationReason String?

  // Relations
  customer       User                   @relation("CustomerBookings", fields: [customerId], references: [id])
  stylist        User                   @relation("StylistBookings", fields: [stylistId], references: [id])
  service        StylistService?        @relation(fields: [serviceId], references: [id])
  statusHistory  BookingStatusHistory[]
  escrowFailures EscrowFailure[]        // M-1: Track escrow failures for this booking

  @@index([customerId])
  @@index([stylistId])
  @@index([serviceId])
  @@index([status])
  @@index([scheduledStartTime])
  @@index([createdAt])
  @@index([status, scheduledStartTime]) // Composite index for status filtering with time range
  @@map("bookings")
}

/// Audit trail for booking status changes
model BookingStatusHistory {
  id        String        @id @default(uuid())
  bookingId String
  fromStatus BookingStatus?
  toStatus  BookingStatus
  changedBy String
  changedAt DateTime      @default(now())
  reason    String?

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [changedBy], references: [id])

  @@index([bookingId])
  @@index([changedAt])
  @@map("booking_status_history")
}

// ============================================================================
// WALLET MODELS (AA Wallet SDK - Task 2)
// ============================================================================

/// ERC-4337 Smart Account wallet for a user
model Wallet {
  id         String   @id @default(uuid())
  userId     String   @unique
  address    String   @unique
  chainId    Int      @default(8453) // Base mainnet
  salt       String   // bytes32 for CREATE2 deterministic deployment
  isDeployed Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions        WalletTransaction[]
  moonPayTransactions MoonPayTransaction[]

  @@index([address])
  @@map("wallets")
}

/// Transaction history for wallet operations
model WalletTransaction {
  id           String            @id @default(uuid())
  walletId     String
  type         TransactionType
  amount       BigInt            // Amount in smallest unit (e.g., USDC has 6 decimals)
  token        String            @default("USDC")
  counterparty String?           // Address of sender/recipient
  txHash       String?           @unique
  userOpHash   String?           @unique
  status       TransactionStatus @default(PENDING)
  memo         String?
  createdAt    DateTime          @default(now())
  confirmedAt  DateTime?

  // Relations
  wallet             Wallet              @relation(fields: [walletId], references: [id], onDelete: Cascade)
  moonPayTransaction MoonPayTransaction?

  @@index([walletId, createdAt])
  @@index([status])
  @@map("wallet_transactions")
}

/// Payment request for P2P transfers (QR code payments)
model PaymentRequest {
  id          String               @id @default(uuid())
  recipientId String               // User ID of recipient
  amount      BigInt               // Amount in smallest unit
  memo        String?
  status      PaymentRequestStatus @default(PENDING)
  expiresAt   DateTime
  payerId     String?              // User ID of payer (set when fulfilled)
  txHash      String?              // Transaction hash when fulfilled
  createdAt   DateTime             @default(now())

  @@index([recipientId])
  @@index([status])
  @@map("payment_requests")
}

// ============================================================================
// MOONPAY MODELS (Fiat On/Off-Ramp)
// ============================================================================

/// MoonPay transaction for fiat on/off-ramp
model MoonPayTransaction {
  id        String   @id @default(uuid())
  walletId  String
  sessionId String   @unique // MoonPay transaction ID

  // Transaction type
  type String // "deposit" | "withdrawal"

  // Status
  status String // "pending" | "completed" | "failed"

  // Amounts
  fiatAmount     Decimal // e.g., 100.00 ZAR
  fiatCurrency   String  // "ZAR" | "USD" | "EUR"
  cryptoAmount   Decimal // e.g., 5.405405 USDC
  cryptoCurrency String  @default("USDC")

  // Payment details (deposit)
  paymentMethod String? // "card" | "bank_transfer"
  cardLast4     String? // Last 4 of card

  // Withdrawal details (offramp)
  bankAccountId String? // Reference to saved bank account
  bankName      String?
  accountLast4  String?

  // Metadata
  redirectUrl String? // MoonPay checkout URL
  webhookData Json? // Raw webhook payload

  // Linked to wallet transaction
  walletTransactionId String?            @unique
  walletTransaction   WalletTransaction? @relation(fields: [walletTransactionId], references: [id])

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  // Relations
  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([walletId])
  @@index([sessionId])
  @@index([status])
  @@map("moonpay_transactions")
}

/// Saved payment methods for future use
model SavedPaymentMethod {
  id     String @id @default(uuid())
  userId String

  // Type
  type String // "card" | "bank_account"

  // Card details (masked)
  cardBrand    String? // "visa" | "mastercard"
  cardLast4    String?
  cardExpMonth Int?
  cardExpYear  Int?

  // Bank account details (masked)
  bankName     String?
  accountLast4 String?
  accountType  String? // "checking" | "savings"

  // MoonPay reference
  moonpayId String? @unique // MoonPay customer/card ID

  // Defaults
  isDefault Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("saved_payment_methods")
}

// ============================================================================
// NOTIFICATION MODELS (F4.3: Multi-channel notifications)
// ============================================================================

enum NotificationType {
  BOOKING_CREATED
  BOOKING_APPROVED
  BOOKING_DECLINED
  PAYMENT_CONFIRMED
  SERVICE_STARTED
  SERVICE_COMPLETED
  BOOKING_CANCELLED
  BOOKING_REMINDER
}

enum NotificationChannel {
  EMAIL
  SMS
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  READ
}

/// Notification record for audit trail and in-app display
model Notification {
  id        String   @id @default(uuid())
  userId    String

  // Notification details
  type      NotificationType
  channel   NotificationChannel
  status    NotificationStatus  @default(PENDING)

  // Content
  title     String
  body      String

  // Metadata (booking ID, deep link, etc.)
  metadata  Json?

  // Timestamps
  sentAt    DateTime?
  readAt    DateTime?
  createdAt DateTime @default(now())

  // External service references
  externalId String? // SendGrid message ID, SMS ID, etc.
  error      String? // Error message if failed

  @@index([userId, createdAt])
  @@index([userId, status])
  @@index([type])
  @@map("notifications")
}

// ============================================================================
// PAYMASTER MONITORING MODELS (F5.1: Gas Sponsorship Tracking)
// ============================================================================

enum PaymasterTxStatus {
  PENDING
  SUCCESS
  FAILED
}

enum AlertType {
  LOW_BALANCE
  HIGH_USAGE
  ERROR_RATE
}

/// Tracks gas sponsorship for Account Abstraction UserOperations
model PaymasterTransaction {
  id         String            @id @default(uuid())
  userOpHash String            @unique // UserOperation hash
  sender     String            // AA wallet address that was sponsored

  // Gas metrics
  gasUsed    BigInt            // Actual gas used
  gasPrice   BigInt            // Gas price in wei
  totalCost  BigInt            // Total cost in wei (gasUsed * gasPrice)

  // Transaction details
  txHash     String?           // On-chain transaction hash
  status     PaymasterTxStatus @default(PENDING)

  // Error tracking
  error      String?           // Error message if failed

  // Timestamps
  createdAt  DateTime          @default(now())
  confirmedAt DateTime?

  @@index([createdAt])
  @@index([sender])
  @@index([status])
  @@map("paymaster_transactions")
}

/// Alert configuration for paymaster monitoring
model PaymasterAlert {
  id          String    @id @default(uuid())
  type        AlertType
  threshold   Float     // Threshold value (e.g., 0.01 ETH for LOW_BALANCE)
  isActive    Boolean   @default(true)

  // Last trigger info
  lastTriggered DateTime?
  lastValue     Float?    // Value when last triggered

  // Notification settings
  notifySlack   Boolean   @default(true)
  notifyEmail   Boolean   @default(true)
  emailRecipients String? // Comma-separated emails

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([type])
  @@map("paymaster_alerts")
}

/// Daily aggregated stats for paymaster dashboard
model PaymasterDailyStats {
  id              String   @id @default(uuid())
  date            DateTime @unique @db.Date // Date only, no time

  // Transaction counts
  totalTxCount    Int      @default(0)
  successTxCount  Int      @default(0)
  failedTxCount   Int      @default(0)

  // Gas metrics
  totalGasUsed    BigInt   @default(0)
  totalCostWei    BigInt   @default(0)
  avgGasPrice     BigInt   @default(0)

  // Unique users
  uniqueUsers     Int      @default(0)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([date])
  @@map("paymaster_daily_stats")
}

// ============================================================================
// PROPERTY OWNER & CHAIR RENTAL MODELS (V1.5 - Property Owner Module)
// Reference: docs/vlossom/17-property-owner-and-chair-rental-module.md
// ============================================================================

enum PropertyCategory {
  LUXURY
  BOUTIQUE
  STANDARD
  HOME_BASED
}

enum PropertyApprovalMode {
  FULL_APPROVAL       // Every booking requires owner approval
  NO_APPROVAL         // Auto-confirm unless blocklisted
  CONDITIONAL         // Auto-approve based on rules
}

enum ChairType {
  BRAID_CHAIR
  BARBER_CHAIR
  STYLING_STATION
  WASH_STATION
  MAKEUP_STATION
  NAIL_STATION
  GENERAL
}

enum ChairStatus {
  AVAILABLE
  OCCUPIED
  MAINTENANCE
  BLOCKED
}

enum ChairRentalMode {
  PER_BOOKING   // Split model - fee per booking
  PER_HOUR
  PER_DAY
  PER_WEEK
  PER_MONTH
}

enum ChairRentalStatus {
  PENDING_APPROVAL
  APPROVED
  ACTIVE
  COMPLETED
  CANCELLED
  REJECTED
}

/// Property/Salon entity - container for chairs
model Property {
  id          String           @id @default(uuid())
  ownerId     String           // User ID of property owner
  name        String
  description String?
  category    PropertyCategory @default(STANDARD)

  // Location
  address     String
  city        String
  country     String           @default("ZA")
  lat         Float
  lng         Float

  // Media
  images      Json             @default("[]") // string[] - Cloudinary URLs
  coverImage  String?

  // Operating hours (JSON: {mon: {open: "08:00", close: "18:00"}, ...})
  operatingHours Json          @default("{}")

  // Approval settings
  approvalMode      PropertyApprovalMode @default(CONDITIONAL)
  minStylistRating  Float?               // Minimum reputation score for auto-approval
  minTpsScore       Float?               // Minimum TPS for auto-approval
  allowedCategories Json                 @default("[]") // Service categories allowed
  blockedCategories Json                 @default("[]") // Service categories blocked

  // Status
  isActive    Boolean          @default(true)
  isVerified  Boolean          @default(false)

  // Timestamps
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  chairs           Chair[]
  blocklist        PropertyBlocklist[]
  rentalRequests   ChairRentalRequest[]

  @@index([ownerId])
  @@index([city])
  @@index([isActive])
  @@index([lat, lng])
  @@map("properties")
}

/// Individual rentable chair within a property
model Chair {
  id          String      @id @default(uuid())
  propertyId  String
  name        String      // "Chair 1", "Station A", etc.
  type        ChairType   @default(GENERAL)
  status      ChairStatus @default(AVAILABLE)

  // Amenities (flags for filtering/matching)
  amenities   Json        @default("[]") // string[]: "wash_basin", "mirror", "lighting", etc.

  // Pricing (in cents)
  hourlyRateCents   BigInt?
  dailyRateCents    BigInt?
  weeklyRateCents   BigInt?
  monthlyRateCents  BigInt?
  perBookingFeeCents BigInt?  // Fee added per booking when chair is used

  // Rental modes enabled for this chair
  rentalModesEnabled Json    @default("[\"PER_BOOKING\"]") // ChairRentalMode[]

  // Availability exceptions (maintenance, blackouts)
  exceptions  Json        @default("[]") // [{date: "2025-12-25", blocked: true, note: "Holiday"}]

  // Status
  isActive    Boolean     @default(true)

  // Timestamps
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  property       Property            @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  rentals        ChairRentalRequest[]
  reservations   ChairReservation[]

  @@index([propertyId])
  @@index([type])
  @@index([status])
  @@index([isActive])
  @@map("chairs")
}

/// Chair rental request from stylist
model ChairRentalRequest {
  id          String            @id @default(uuid())
  chairId     String
  propertyId  String
  stylistId   String            // User ID of stylist

  // Rental details
  rentalMode  ChairRentalMode
  startTime   DateTime
  endTime     DateTime

  // Pricing (calculated at request time)
  totalAmountCents BigInt
  platformFeeCents BigInt
  ownerPayoutCents BigInt

  // Status
  status      ChairRentalStatus @default(PENDING_APPROVAL)

  // Approval tracking
  approvedAt  DateTime?
  approvedBy  String?           // User ID of approver (owner or auto)
  rejectedAt  DateTime?
  rejectionReason String?

  // Escrow
  escrowId    String?
  escrowStatus EscrowStatus?

  // Timestamps
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  // Relations
  chair       Chair             @relation(fields: [chairId], references: [id])
  property    Property          @relation(fields: [propertyId], references: [id])

  @@index([chairId])
  @@index([propertyId])
  @@index([stylistId])
  @@index([status])
  @@index([startTime])
  @@map("chair_rental_requests")
}

/// Chair reservation for a specific booking (per-booking model)
model ChairReservation {
  id          String    @id @default(uuid())
  chairId     String
  bookingId   String    @unique // One chair per booking
  startTime   DateTime
  endTime     DateTime

  // Fee for this reservation
  feeCents    BigInt

  // Timestamps
  createdAt   DateTime  @default(now())

  // Relations
  chair       Chair     @relation(fields: [chairId], references: [id])

  @@index([chairId])
  @@index([bookingId])
  @@index([startTime, endTime])
  @@map("chair_reservations")
}

/// Stylist blocklist for a property
model PropertyBlocklist {
  id          String    @id @default(uuid())
  propertyId  String
  stylistId   String    // User ID of blocked stylist
  reason      String?
  blockedAt   DateTime  @default(now())
  blockedBy   String    // User ID of owner who blocked

  // Relations
  property    Property  @relation(fields: [propertyId], references: [id], onDelete: Cascade)

  @@unique([propertyId, stylistId])
  @@index([propertyId])
  @@index([stylistId])
  @@map("property_blocklist")
}

// ============================================================================
// REPUTATION & REVIEW MODELS (V1.5 - Reputation System)
// Reference: docs/vlossom/08-reputation-system-flow.md
// ============================================================================

enum ReviewType {
  CUSTOMER_TO_STYLIST     // Customer reviews stylist after service
  STYLIST_TO_CUSTOMER     // Stylist reviews customer after service
  PROPERTY_TO_STYLIST     // Property owner reviews stylist
  STYLIST_TO_PROPERTY     // Stylist reviews property/chair
}

/// Structured review after service completion
model Review {
  id          String     @id @default(uuid())
  bookingId   String
  reviewerId  String     // User ID of reviewer
  revieweeId  String     // User ID of person being reviewed
  reviewType  ReviewType

  // Structured ratings (1-5 scale stored as 10-50 for precision)
  overallRating       Int       // Required overall score
  professionalismRating Int?    // For stylists: professionalism
  communicationRating Int?      // Communication quality
  cleanlinessRating   Int?      // For stylists/properties: cleanliness
  punctualityRating   Int?      // Was on time?
  qualityRating       Int?      // Service quality / space quality

  // Optional text feedback
  comment     String?   @db.VarChar(500)

  // Review status
  isPublic    Boolean   @default(true)
  isVerified  Boolean   @default(false) // Verified completed booking

  // Timestamps
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@unique([bookingId, reviewType]) // One review per type per booking
  @@index([revieweeId])
  @@index([reviewerId])
  @@index([reviewType])
  @@index([createdAt])
  @@map("reviews")
}

/// Reputation event log for tracking all reputation-affecting actions
model ReputationEvent {
  id          String    @id @default(uuid())
  actorId     String    // User ID affected
  actorType   ActorRole // STYLIST, CUSTOMER, PROPERTY_OWNER
  bookingId   String?

  // Event details
  eventType   String    // BOOKING_COMPLETED, ON_TIME_ARRIVAL, LATE_ARRIVAL, etc.
  scoreImpact Int       // Positive or negative impact (-100 to +100)

  // Metadata
  metadata    Json      @default("{}") // Additional event-specific data

  // Timestamps
  createdAt   DateTime  @default(now())

  @@index([actorId])
  @@index([actorType])
  @@index([eventType])
  @@index([createdAt])
  @@map("reputation_events")
}

/// Aggregated reputation score for an actor (cached/computed)
model ReputationScore {
  id          String    @id @default(uuid())
  userId      String    @unique
  actorType   ActorRole

  // Score components (0-10000 representing 0.00-100.00)
  totalScore        Int       @default(5000)
  tpsScore          Int       @default(5000) // Time Performance Score
  reliabilityScore  Int       @default(5000) // Booking completion rate
  feedbackScore     Int       @default(5000) // Average review rating
  disputeScore      Int       @default(10000) // Lower = more disputes

  // Stats
  completedBookings Int       @default(0)
  cancelledBookings Int       @default(0)
  totalReviews      Int       @default(0)
  averageRating     Float?    // Computed average of all review ratings

  // Verification status
  isVerified        Boolean   @default(false)
  verifiedAt        DateTime?

  // Timestamps
  lastCalculatedAt  DateTime  @default(now())
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  @@index([totalScore])
  @@index([actorType])
  @@index([isVerified])
  @@map("reputation_scores")
}

/// Dispute raised for a booking
model Dispute {
  id              String            @id @default(uuid())
  bookingId       String
  filedById       String            // User who filed the dispute
  filedAgainstId  String            // User the dispute is against

  // Dispute details
  type            DisputeType
  status          DisputeStatus     @default(OPEN)
  priority        Int               @default(1) // 1-5, higher = more urgent

  // Description
  title           String            @db.VarChar(200)
  description     String            @db.Text

  // Evidence
  evidenceUrls    Json              @default("[]") // Array of image/document URLs

  // Assignment
  assignedToId    String?           // Admin assigned to handle
  assignedAt      DateTime?

  // Resolution
  resolution      DisputeResolution?
  resolutionNotes String?           @db.Text
  refundPercent   Int?              // For partial refunds (0-100)
  resolvedAt      DateTime?
  resolvedById    String?           // Admin who resolved

  // Escalation
  escalatedAt     DateTime?
  escalatedById   String?
  escalationReason String?         @db.VarChar(500)

  // Timestamps
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([bookingId])
  @@index([filedById])
  @@index([filedAgainstId])
  @@index([assignedToId])
  @@index([status])
  @@index([priority])
  @@index([createdAt])
  @@map("disputes")
}

/// Messages/comments on a dispute for communication thread
model DisputeMessage {
  id          String    @id @default(uuid())
  disputeId   String
  authorId    String    // User or admin who wrote

  // Content
  content     String    @db.Text
  isInternal  Boolean   @default(false) // Internal admin notes

  // Attachments
  attachmentUrls Json   @default("[]")

  // Timestamps
  createdAt   DateTime  @default(now())

  @@index([disputeId])
  @@index([authorId])
  @@map("dispute_messages")
}

/// Admin audit log for compliance and tracking
model AuditLog {
  id          String    @id @default(uuid())
  adminId     String    // Admin who performed the action
  action      String    // FREEZE_USER, RESOLVE_DISPUTE, VERIFY_PROPERTY, etc.
  targetType  String    // USER, BOOKING, PROPERTY, DISPUTE, etc.
  targetId    String    // ID of the affected entity

  // Details
  details     String?   @db.Text
  metadata    Json      @default("{}") // Additional action-specific data

  // IP tracking for security
  ipAddress   String?
  userAgent   String?

  // Timestamps
  createdAt   DateTime  @default(now())

  @@index([adminId])
  @@index([action])
  @@index([targetType])
  @@index([targetId])
  @@index([createdAt])
  @@map("audit_logs")
}

// ============================================================================
// ESCROW FAILURE TRACKING (M-1: V1.7.0 Security & Quality)
// Reference: docs/vlossom/05-booking-flow.md
// ============================================================================

enum EscrowFailureStatus {
  PENDING_REVIEW      // Needs manual review
  RESOLVED            // Successfully resolved
  MANUAL_INTERVENTION // Required manual intervention
}

enum EscrowOperationType {
  LOCK      // Customer locking funds
  RELEASE   // Releasing to stylist after completion
  REFUND    // Refunding to customer after cancellation
}

/// Tracks failed escrow operations for manual review and resolution
/// M-1: Provides visibility into blockchain failures for ops team
model EscrowFailure {
  id            String               @id @default(uuid())
  bookingId     String
  operation     EscrowOperationType
  errorMessage  String
  txHash        String?              // Transaction hash if available
  status        EscrowFailureStatus  @default(PENDING_REVIEW)

  // Resolution tracking
  resolvedAt    DateTime?
  resolvedBy    String?              // User ID of admin who resolved
  resolution    String?              // Description of resolution

  // Additional context
  amount        BigInt?              // Amount involved in failed operation
  metadata      Json                 @default("{}") // Additional error context

  // Timestamps
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  // Relations
  booking       Booking              @relation(fields: [bookingId], references: [id])

  @@index([status])
  @@index([createdAt])
  @@index([bookingId])
  @@map("escrow_failures")
}

// ============================================================================
// IDEMPOTENCY KEYS (M-2: V1.7.0 Security & Quality)
// Reference: Stripe-style idempotency for payment operations
// ============================================================================

/// Tracks idempotent requests to prevent duplicate operations
/// M-2: Ensures payment operations are not duplicated on network retry
model IdempotentRequest {
  key        String   @id                  // Client-provided idempotency key
  response   Json                          // Cached response to return
  statusCode Int                           // HTTP status code of original response
  expiresAt  DateTime                      // Auto-cleanup after expiry
  createdAt  DateTime @default(now())

  @@index([expiresAt])
  @@map("idempotent_requests")
}

// ============================================================================
// EXTERNAL AUTH PROVIDERS (V3.2: SIWE - Sign In With Ethereum)
// Reference: docs/vlossom/14-backend-architecture-and-apis.md
// ============================================================================

enum AuthProvider {
  EMAIL      // Traditional email/password
  ETHEREUM   // SIWE - Sign In With Ethereum
}

/// External authentication provider for a user (SIWE, OAuth, etc.)
/// V3.2: Enables wallet-based authentication alongside email/password
model ExternalAuthProvider {
  id         String       @id @default(uuid())
  userId     String
  provider   AuthProvider
  address    String       @unique  // Wallet address for ETHEREUM provider
  chainId    Int?                  // Chain ID for ETHEREUM provider

  // Metadata
  metadata   Json         @default("{}")  // Provider-specific data

  // Timestamps
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, address])
  @@index([userId])
  @@index([address])
  @@map("external_auth_providers")
}

/// Linked accounts for multi-auth support (email + wallet linking)
/// V3.2: Allows users to link multiple authentication methods to one account
model LinkedAccount {
  id          String       @id @default(uuid())
  userId      String
  provider    AuthProvider
  identifier  String       // Email address or wallet address
  isPrimary   Boolean      @default(false)
  verifiedAt  DateTime?    // When this auth method was verified

  // Timestamps
  createdAt   DateTime     @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, provider, identifier])
  @@unique([provider, identifier])  // Prevent same identifier across users
  @@index([userId])
  @@map("linked_accounts")
}

// ============================================================================
// SIWE NONCE TRACKING (V3.2: Replay Attack Prevention)
// ============================================================================

/// SIWE nonce for replay attack prevention
/// V3.2: Each nonce is single-use and expires after 5 minutes
model SiweNonce {
  id         String   @id @default(uuid())
  nonce      String   @unique
  address    String?  // Optional: Pre-associate with address
  isUsed     Boolean  @default(false)
  expiresAt  DateTime
  createdAt  DateTime @default(now())

  @@index([nonce])
  @@index([expiresAt])
  @@map("siwe_nonces")
}

// ============================================================================
// REWARDS & XP SYSTEM (V3.4: Rewards Engine)
// Reference: docs/vlossom/09-rewards-and-incentives-engine.md
// ============================================================================

enum UserTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
  DIAMOND
}

enum BadgeType {
  // Booking milestones
  FIRST_BOOKING
  TEN_BOOKINGS
  FIFTY_BOOKINGS
  HUNDRED_BOOKINGS

  // Performance badges
  PERFECT_TPS_MONTH
  FIVE_STAR_STREAK
  PUNCTUALITY_PRO

  // Community badges
  TOP_REFERRER
  COMMUNITY_BUILDER

  // Special badges
  EARLY_ADOPTER
  VERIFIED_STYLIST
  PREMIUM_HOST
  MASTER_BRAIDER

  // Seasonal badges
  HOLIDAY_HERO
  SUMMER_STAR
}

/// User XP and points tracking
/// V3.4: Tracks experience points, role points, streaks, and tier progression
model UserXP {
  id             String   @id @default(uuid())
  userId         String   @unique

  // Experience points (global)
  totalXP        Int      @default(0)

  // Role-specific points
  stylistPoints  Int      @default(0)
  customerPoints Int      @default(0)
  ownerPoints    Int      @default(0)

  // Referral metrics
  referralScore  Int      @default(0)
  referralCount  Int      @default(0)

  // Streak tracking
  currentStreak  Int      @default(0)   // Current consecutive days/bookings
  longestStreak  Int      @default(0)   // Best streak ever
  streakType     String   @default("bookings") // "bookings" | "days"
  lastActivityAt DateTime?

  // Tier (computed from XP)
  tier           UserTier @default(BRONZE)

  // Timestamps
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([totalXP])
  @@index([tier])
  @@index([referralScore])
  @@map("user_xp")
}

/// Earned badges for a user
/// V3.4: Soulbound badges representing achievements
model UserBadge {
  id        String    @id @default(uuid())
  userId    String
  badgeType BadgeType

  // When earned
  earnedAt  DateTime  @default(now())

  // Additional metadata (e.g., specific achievement details)
  metadata  Json      @default("{}")

  // Notification sent
  notifiedAt DateTime?

  @@unique([userId, badgeType])
  @@index([userId])
  @@index([badgeType])
  @@index([earnedAt])
  @@map("user_badges")
}

/// XP event log for tracking all XP-earning actions
/// V3.4: Audit trail for XP changes
model XPEvent {
  id          String   @id @default(uuid())
  userId      String

  // Event details
  eventType   String   // BOOKING_COMPLETED, REVIEW_LEFT, REFERRAL, etc.
  xpAwarded   Int      // Amount of XP awarded

  // Categorization
  category    String   // "booking", "review", "referral", "streak", "special"

  // Related entities
  bookingId   String?
  referralId  String?  // User ID of referred user (if referral event)

  // Additional context
  metadata    Json     @default("{}")

  // Timestamp
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([eventType])
  @@index([category])
  @@index([createdAt])
  @@map("xp_events")
}

/// Referral tracking
/// V3.4: Tracks referral relationships and performance
model Referral {
  id           String   @id @default(uuid())
  referrerId   String   // User who made the referral
  refereeId    String   @unique // User who was referred

  // Referral code used
  referralCode String

  // Referee activity metrics (updated periodically)
  refereeTotalBookings Int @default(0)
  refereeSpentAmount   BigInt @default(0) // In cents
  refereeIsActive      Boolean @default(false)

  // Rewards tracking
  referrerXPAwarded    Int @default(0)
  refereeXPAwarded     Int @default(0)

  // Timestamps
  createdAt    DateTime @default(now())
  activatedAt  DateTime? // When referee completed first booking

  @@index([referrerId])
  @@index([referralCode])
  @@map("referrals")
}

/// User referral codes
/// V3.4: Each user gets unique referral codes
model ReferralCode {
  id       String  @id @default(uuid())
  userId   String  @unique
  code     String  @unique // Unique referral code

  // Usage stats
  usageCount Int   @default(0)

  // Customization (future)
  customCode String? @unique // User can set custom code

  // Timestamps
  createdAt  DateTime @default(now())

  @@index([code])
  @@index([customCode])
  @@map("referral_codes")
}

// ============================================================================
// DEFI & LIQUIDITY POOL MODELS (V4.0: DeFi Integration)
// Reference: docs/vlossom/11-defi-and-liquidity-architecture.md
// Reference: docs/vlossom/12-liquidity-pool-architecture.md
// ============================================================================

enum PoolTier {
  GENESIS   // Protocol-managed pool (VLP)
  TIER_1    // Top 5% referrers - no cap
  TIER_2    // Top 15% referrers - $100k cap
  TIER_3    // Top 30% referrers - $20k cap
}

enum PoolStatus {
  ACTIVE
  PAUSED
  DEPRECATED
}

/// Liquidity pool entity (Genesis + Community pools)
/// V4.0: Tracks on-chain pool state in database
model LiquidityPool {
  id            String     @id @default(uuid())
  address       String     @unique  // On-chain contract address
  name          String
  tier          PoolTier
  creatorId     String?              // User ID of creator (null for genesis)
  status        PoolStatus @default(ACTIVE)

  // On-chain synced state
  totalDeposits Decimal    @default(0) @db.Decimal(20, 6)  // Total USDC deposited
  totalShares   Decimal    @default(0) @db.Decimal(30, 18) // Total LP shares
  supplyIndex   Decimal    @default(1) @db.Decimal(30, 18) // Yield index
  currentAPY    Decimal    @default(0) @db.Decimal(10, 4)  // Current APY %

  // Pool configuration
  cap           Decimal?   @db.Decimal(20, 6)              // Deposit cap (null = no cap)
  creatorFeeBps Int        @default(0)                     // Creator fee basis points
  isGenesis     Boolean    @default(false)

  // Stats
  totalYieldDistributed Decimal @default(0) @db.Decimal(20, 6)
  depositorCount        Int     @default(0)

  // Timestamps
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  lastSyncAt    DateTime   @default(now())  // Last blockchain sync

  // Relations
  deposits      LiquidityDeposit[]
  yieldClaims   YieldClaim[]

  @@index([tier])
  @@index([status])
  @@index([isGenesis])
  @@index([creatorId])
  @@map("liquidity_pools")
}

/// User deposit in a liquidity pool
/// V4.0: Tracks individual user positions
model LiquidityDeposit {
  id            String   @id @default(uuid())
  userId        String
  poolId        String

  // Position
  shares        Decimal  @db.Decimal(30, 18) // LP shares owned
  depositAmount Decimal  @db.Decimal(20, 6)  // Original USDC deposited
  depositIndex  Decimal  @db.Decimal(30, 18) // Index at deposit time

  // Transactions
  depositTxHash String?
  lastClaimAt   DateTime?

  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  pool LiquidityPool @relation(fields: [poolId], references: [id])

  @@unique([userId, poolId])
  @@index([userId])
  @@index([poolId])
  @@map("liquidity_deposits")
}

/// Yield claim record
/// V4.0: Tracks yield claims for accounting
model YieldClaim {
  id        String   @id @default(uuid())
  userId    String
  poolId    String
  amount    Decimal  @db.Decimal(20, 6)  // USDC claimed
  txHash    String?

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  pool LiquidityPool @relation(fields: [poolId], references: [id])

  @@index([userId])
  @@index([poolId])
  @@index([createdAt])
  @@map("yield_claims")
}

/// DeFi tier status for a user
/// V4.0: Caches user's referral percentile and DeFi tier
model DefiTierStatus {
  id                 String    @id @default(uuid())
  userId             String    @unique
  referralPercentile Float     @default(100) // 0 = top, 100 = bottom
  tier               PoolTier? // null if below Tier 3 (>30%)
  canCreatePool      Boolean   @default(false)

  // Last calculation
  lastCalculatedAt   DateTime  @default(now())

  // Timestamps
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@index([tier])
  @@index([referralPercentile])
  @@map("defi_tier_status")
}

// ============================================================================
// SYSTEM CONFIGURATION
// ============================================================================

/// System configuration key-value store
/// V4.0: Stores DeFi parameters and other system-wide settings
model SystemConfig {
  key       String   @id
  value     String   @db.Text // JSON value
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

